import json
import re
from difflib import SequenceMatcher
from typing import Dict

import pymongo
from bson import json_util
from elasticsearch import Elasticsearch
from elasticsearch import helpers
from functional import seq
import nltk

nltk.download('punkt')
product_vendor_file_path = "../resource/product_vendors.txt"
same_service_name_dict = {
    "internet_information_server": "iis",
    "internet_information_services": "iis",
    "merak_mail_server": "mail_server",
    "icewarp_mail_server": "mail_server",
    "database_server": "database",
    "oracle_database": "database",
    "telepresence_tc": "telepresence_tc_software",
    "liferay": "liferay_portal",
    "joomla\\!": "joomla",
    "plone_cms": "plone",
    "kentico_cms": "kentico",
    "evolution_cms": "modx_revolution",
    "phusion_passenger": "passenger",
    "macos": "mac_os",
    "qnx": "qnx_neutrino_rtos",
    "qnx_rtos": "qnx_neutrino_rtos",
    "rtos": "qnx_neutrino_rtos",
    "neutrino_rtos": "qnx_neutrino_rtos",
}


def product_vendor_file2dict(file_path) -> Dict[str, list]:
    out_dict = {}
    contents = open(file_path)
    for line in contents.readlines():
        parts_t = line.split(":")
        out_dict[parts_t[0].lower()] = parts_t[1].strip().lower().split(',')
    return out_dict


def version2standard(version):
    same_versions_re = re.compile("([.0-9]+)(?:\.0+)+$")
    flag_version = True
    while flag_version:
        match = same_versions_re.match(version)
        if match:
            version = match.group(1)
        else:
            flag_version = False
    return version


def is_similar_to(the_word, services_list) -> Dict:
    max_similarity = None
    for idx, item in enumerate(services_list):
        item_name = item['name']
        value = SequenceMatcher(None, the_word, item_name).ratio()
        if idx == 0:
            max_similarity = [item, value]
        elif max_similarity[1] < value:
            max_similarity = [item, value]
    if max_similarity is not None:
        return max_similarity[0]


def split_sentences(text):
    output_list = []
    first_list = text.split('\n')
    for item in first_list:
        item = item.strip()
        output_list += nltk.sent_tokenize(item)
    return output_list


def score_label(score):
    if score is None:
        return "None"

    score = float(score)
    if score == 0.0:
        return "None"
    if 0.1 <= score <= 3.9:
        return "Low"
    if 4.0 <= score <= 6.9:
        return "Medium"
    if 7.0 <= score <= 8.9:
        return "High"
    if 9.0 <= score:
        return "Critical"


es = Elasticsearch(hosts="81.91.132.134:9200")
mongo_client = pymongo.MongoClient("mongodb://localhost:27017/")["cvedb"]
collection = mongo_client["cves"]

summary01_re = re.compile("(?:should|encouraged to|\.|and)\s+update\s+to\s*([- _.A-Za-z0-9]*?)"
                          "(\d+(?:\.\d+)+(?:\(\d\w?\))?)",
                          re.IGNORECASE)
summary02_re = re.compile("(?:fixed in|fixed and published in|patched in|addressed by patch in|should upgrade to)\s*"
                          "([- _.A-Za-z0-9]*?)(\d+(?:\.\d+)+\w*(?:-\d+(?:\.\d+)*|-[\d\w]+|(?:\(\d\w?\)(?:SU\d)?)?)?)",
                          re.IGNORECASE)
product_vendor_dic = product_vendor_file2dict(product_vendor_file_path)
actions = []
count = 0
cve_dic = {}
cve_detail_dic = {}
cve_cursor = collection.find()
for cve in cve_cursor:
    configs = cve['vulnerable_product']

    results = []
    services = []
    for config in configs:
        parts = config.lower().split(":")
        vendor = parts[3]
        product = parts[4]
        version = parts[5]
        revision = parts[6]

        # if version == "-":  # skip no version
        #     continue

        version = version2standard(version)

        if product in same_service_name_dict:
            product = same_service_name_dict[product]

        # only add results(CVEs) that are for the vendor in dictionary; not others:
        if product_vendor_dic.get(product) is not None:
            if vendor not in product_vendor_dic[product]:
                product = vendor + "_" + product

        # old_cve       # dr. Zarif said to comment this condition!
        # if revision != '*':
        #     q = product + ":" + version + ":" + "*"
        #     if q in results:
        #         results.remove(q)
        ###
        results.append(product + ":" + version + ":" + revision)
        last_product = parts[5] + ":" + revision
        service = next((item for item in services if item['name'] == product), None)
        if service is None:
            service = {"name": product, "last": last_product}
            services.append(service)
        else:
            service['last'] = last_product

    # detection of exclusive versions:
    exclusive_sentences = []
    summary = cve.get('summary')
    if summary is not None:
        summary_sentences = split_sentences(summary)
        for sentence in summary_sentences:
            match = summary01_re.search(sentence) or summary02_re.search(sentence)
            if match:
                if sentence not in exclusive_sentences:
                    exclusive_sentences.append(sentence)

    # if len(services) != 0:
    #     summary = cve.get('summary')
    #     if summary is not None:
    #         match = summary01_re.search(summary) or summary02_re.search(summary)
    #         if match:
    #             service_name = match.group('service').strip()
    #             exclusive_version = match.group('version')
    #             if service_name == "" or service_name == "version":
    #                 if len(services) == 1:
    #                     for ss in services:
    #                         services[ss]['exclusive'] = exclusive_version
    #                         print("{}, {}:{}".format(str(kkkk), service_name, exclusive_version))
    #                         kkkk += 1
    #                         # print(exclusive_version)
    #             else:
    #                 # is_similar("nutch", service_name)
    #                 print("{}, {}:{}".format(str(kkkk), service_name, exclusive_version))
    #                 kkkk += 1
    # else:
    #     services = None

    conf = seq(results).distinct().to_list()
    cve_id = str(cve['id'])
    cve_cvss = cve['cvss']
    if cve_cvss is None:
        cve_cvss = ""
    cve_published = cve['Published']
    if cve_published is None:
        cve_published = ""
    source_dict = {
        "code": cve_id,
        "configuration": conf,
        "date": cve_published,
        "detail": cve['summary'],
        "cvss": cve_cvss,
        "cvss_label": score_label(cve['cvss']),
        "cwe": cve['cwe']
    }
    if cve.get('references') is not None:
        source_dict['references'] = cve['references']
    action = {
        "_index": "cve",
        "_id": cve_id,
        "_source": source_dict
    }
    if services is not None:
        action['_source']['services'] = services
    if len(exclusive_sentences) > 0:
        action['_source']['exclusives'] = exclusive_sentences
    if cve['access']:
        if cve['access']['complexity']:
            action['_source']['complexity'] = cve['access']['complexity']

        if cve['access']['vector']:
            cve_type = cve['access']['vector']
            if cve_type and cve_type == 'NETWORK':
                cve_type = 'REMOTE'
            action['_source']['type'] = cve_type
    # actions.append(json.dumps(record, default=json_util.default))

    actions.append(action)

    # if len(exclusive_sentences) > 0:
    #     if len(services) > 1 or len(exclusive_sentences) > 1:
    #         print()

    # es.index(index='cve', body=body)
    count += 1
    print(str(count))

print("start indexing...")
helpers.bulk(es, actions=actions, chunk_size=500, request_timeout=200)
print("end indexing...")
